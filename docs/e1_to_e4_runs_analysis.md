# Εμπεριστατωμένη αξιολόγηση πειραμάτων E1–E4

## Εισαγωγή
Η παρούσα έκθεση αποτυπώνει μια εκτενή, αναλυτική και ερμηνευτική αξιολόγηση όλων των εκτελέσεων που βρίσκονται στον φάκελο `runs/` και φέρουν ετικέτες από E1 έως και E4. Ο στόχος είναι να παρουσιαστούν όχι μόνο οι αριθμητικοί δείκτες αλλά και το περιεχόμενο των JSON αρχείων κάθε πειράματος, οι μέθοδοι αξιολόγησης, οι προσδοκώμενες («αναμενόμενες») συμπεριφορές, καθώς και μια ερμηνεία του πώς τα αποτελέσματα συνδέονται με τους στόχους δημιουργίας και επιδιόρθωσης οντολογιών ATM. Το κείμενο επεκτείνεται εσκεμμένα ώστε να προσεγγίζει τις 5.000 λέξεις και να λειτουργεί ως πλήρης τεχνική αναφορά.

Η διαδρομή `runs/` περιέχει πολλαπλές παραλλαγές. Τα πειράματα E1 αντιστοιχούν σε καθαρά LLM παραγόμενα γραφήματα με διαφορετικά seeds (`E1_llm_only_seed1`, `E1_llm_only_seed2`). Το E2 χρησιμοποιεί συμβολικές διαδικασίες (π.χ. reasoning και SHACL) χωρίς επανορθώσεις από LLM. Το E3 προσθέτει δεδομένα few-shot αλλά χωρίς κυκλικό repair. Το E4 αφορά πλήρεις ρυθμίσεις repair με διαφοροποιήσεις ως προς το χειρισμό παραβιάσεων (default, hard_and_cq, max_only, ignore_no_hard). Για κάθε εκτέλεση εξετάζουμε: (α) `run_report.json` ή τα αντίστοιχα αρχεία επιμέρους επαναλήψεων, (β) `metrics_semantic.json` και `metrics_exact.json`, (γ) `cq_results.json`, (δ) `validation_summary.json` όπου υπάρχει, (ε) βοηθητικά logs όπως `repair_log.json` και `iteration_log.json`.

Η μετρική αξιολόγηση βασίζεται στην αντιστοίχιση τριπλετών σε σχέση με το gold διάγραμμα. Οι μετρικές `precision`, `recall` και `f1` απεικονίζουν, αντιστοίχως, την καθαρότητα, την κάλυψη και τη συνδυαστική αρμονική αυτών. Τα JSON αρχεία προσφέρουν επίσης τον αριθμό προβλεπόμενων (`pred_triples`), χρυσών (`gold_triples`) και επικαλυπτόμενων (`overlap_triples`) τριπλετών. Σε ορισμένες περιπτώσεις οι τιμές `metrics_semantic` και `metrics_exact` συμπίπτουν, υποδεικνύοντας μη ύπαρξη πρόσθετης χαλάρωσης στην αντιστοίχιση. Τα `cq_results.json` αποτυπώνουν την επιτυχία σε 21 competency questions (CQs) με δείκτη `pass_rate` καθώς και επιμέρους `success` flags.

Στις ενότητες που ακολουθούν παρουσιάζονται λεπτομερώς οι παρατηρήσεις ανά εκτέλεση, με αναφορά τόσο στα αριθμητικά όσο και στα περιγραφικά στοιχεία των JSON. Σε κάθε υποενότητα παρατίθενται οι αναμενόμενες συμπεριφορές (π.χ. υψηλότερη ακρίβεια σε συγκεκριμένες διαδρομές, ευαισθησία σε repair βημάτων κ.λπ.) ώστε να διευκολυνθεί η συσχέτιση αποτελεσμάτων με θεωρητική πρόβλεψη.

## Πείραμα E1 – LLM μόνο, seed 1
Το `runs/E1_llm_only_seed1/run_report.json` δηλώνει `mode: "draft_only"`, 156 παραγόμενες τριπλέτες και κατανάλωση 1.559 tokens (1.128 prompt, 431 completion). Το LLM λειτουργεί χωρίς μετέπειτα reasoning ή SHACL, άρα οι αναμενόμενες αποκλίσεις από το gold είναι αυξημένες. Το JSON δείχνει μηδενικές καταγραφές σε `drift_axioms_sample` και `redundant_axioms_sample`, στοιχείο που φανερώνει ότι δεν έγινε απόπειρα εντοπισμού άσχετων αξιωμάτων.

Το αρχείο `metrics_semantic.json` (και ταυτόσημο `metrics_exact.json`) αναφέρει `precision: 0.4295`, `recall: 0.536`, `f1: 0.4769`, με `pred_triples: 156`, `gold_triples: 125`, `overlap_triples: 67`. Η αναμενόμενη συμπεριφορά για ένα draft-only LLM είναι μέτρια κάλυψη και σημαντική ύπαρξη θορύβου. Το precision ~0.43 υποδηλώνει σχεδόν 57% ψευδώς θετικές τριπλέτες, ενώ το recall ~0.54 δηλώνει ότι περίπου οι μισές χρυσές τριπλέτες λήφθηκαν. Το γεγονός ότι semantic και exact ταυτίζονται μαρτυρά ότι οι ταιριάξεις δεν επωφελήθηκαν από επιπλέον χαλαρούς ελέγχους.

Το `cq_results.json` εμφανίζει `pass_rate: 0.5238`, δηλαδή 11/21 επιτυχίες. Αναλυτικά:
- Οι βασικές οντότητες (ATM, Bank, Customer, Account κ.λπ.) δηλώνονται ως τάξεις (`success: true`). Αναμενόμενο, καθώς αποτελούν συχνές έννοιες του prompt.
- Η ιεραρχία `Withdrawal` ⊑ `Transaction` τηρείται (`success: true`), ενώ η ανάλογη για `Deposit` αποτυγχάνει (`success: false`), γεγονός που δείχνει ασυνεπή κάλυψη για τις δύο υπο-διεργασίες συναλλαγής.
- Οι ιδιότητες διασύνδεσης ATM με Transaction ή CashCard (`handlesTransaction`/`accepts`) επιβεβαιώνονται, όπως και η σύνδεση ATM–Bank μέσω `operatedBy` ή περιορισμών allValuesFrom. Αυτό ταιριάζει με την αναμενόμενη αναπαράσταση λειτουργικής σχέσης.
- Οι ερωτήσεις που αφορούν bank code datatype (`bankCode`), χρονική σήμανση συναλλαγών (`transactionTimestamp`), αριθμητικό ποσό (`requestedAmount`/`transactionAmount`) και πεδία ανάληψης (`dispensedAmount`) περνούν, υποδηλώνοντας ότι το μοντέλο τείνει να κρατά γνωστούς τύπους δεδομένων.
- Αποτυγχάνουν ζητήματα εξόδου μετρητών (`dispenses`), UI display unions, εφεδρικής τροφοδοσίας, χρονισμών επαλήθευσης PIN/κάρτας, διπλής επικοινωνίας με BankComputer, ενημέρωσης μετρικών, δομής απαιτήσεων και πληκτρολογίων. Αυτά είναι πιο δομικά/λειτουργικά χαρακτηριστικά, λιγότερο προφανή στο prompt, και συνεπώς η αποτυχία είναι αναμενόμενη.

Συνολικά, ο συνδυασμός μέσης ακρίβειας, περιορισμένης κάλυψης, και 52% επιτυχίας στα CQs ταιριάζει με την προσδοκία για ένα single-shot LLM χωρίς καθοδήγηση. Αναμενόμενο αποτέλεσμα θα ήταν βελτίωση με πρόσθετα στοιχεία (few-shot, reasoning, repair), κάτι που επιβεβαιώνουν τα επόμενα πειράματα.

## Πείραμα E1 – LLM μόνο, seed 2
Το `run_report.json` δείχνει 190 παραγόμενες τριπλέτες, `mode: "draft_only"`, και χαμηλότερη κατανάλωση completion tokens (288). Η αύξηση τριπλετών σε σχέση με το seed 1 δηλώνει μεγαλύτερη «φλυαρία» του LLM, κάτι που συνήθως μειώνει το precision. Το `metrics_semantic.json` αναφέρει `precision: 0.0895`, `recall: 0.136`, `f1: 0.1079`, με `overlap_triples: 17`. Η τεράστια πτώση precision/recall σε σχέση με seed 1 είναι σύμφωνη με την αναμενόμενη στοχαστικότητα του LLM: περισσότερες εφευρεθείσες τριπλέτες, λιγότερη αντιστοίχιση στο gold.

Το `cq_results.json` έχει `pass_rate: 0.0952`, δηλαδή μόλις 2/21 επιτυχίες. Αυτό το αποτέλεσμα ευθυγραμμίζεται με την εικόνα μετρικών: το διάγραμμα είναι γεμάτο θόρυβο και παραλείψεις. Από άποψη αναμενόμενης συμπεριφοράς, η δραματική απόκλιση μεταξύ δύο seeds υπογραμμίζει την ευαισθησία του συστήματος σε τυχαίες διατυπώσεις και ενισχύει την ανάγκη για σταθεροποίηση μέσω σταδιακών ελέγχων ή few-shot παραδειγμάτων. Η σύγκριση με seed1 καταδεικνύει ότι η απλή αύξηση του αριθμού τριπλετών δεν συνεπάγεται μεγαλύτερη κάλυψη, αλλά συχνά επιβαρύνει την ακρίβεια.

## Σύνοψη E1
Σε επίπεδο προσδοκώμενων αποτελεσμάτων, το seed1 αντιπροσωπεύει ένα «καλύτερο σενάριο» για LLM-only παραγωγή με αξιοπρεπές F1 (~0.48) και μέσο CQ pass rate (~52%). Το seed2 αντιπροσωπεύει «χειρότερο σενάριο» με δραματική πτώση. Η μέση συμπεριφορά μεταξύ των δύο θα τοποθετούσε το LLM-only γύρω σε F1 0.29–0.30 και pass rate περί το 30%, γεγονός που τονίζει ότι χωρίς guidance η προσδοκία πρέπει να είναι μέτρια αξιοπιστία.

## Πείραμα E2 – Συμβολική επεξεργασία χωρίς repair
Το `runs/E2_symbolic_only/run_report.json` περιλαμβάνει πλήρες σύνολο στοιχείων: 1.697 συνολικά tokens, `few_shot_exemplars: null`, SHACL με `conforms: true` και κενό `results`. Το σημαντικότερο: `competency_questions` με 12/12 επιτυχίες (pass rate 1.0). Η παρουσία reasoner (`pellet`) με `consistent: true` και 36 δηλωμένες ελλείπουσες `owl:Class` ενισχύει την τυπική ποιότητα του μοντέλου. Η προσδοκώμενη συμπεριφορά μιας συμβολικής ανακατασκευής είναι υψηλή δομική ορθότητα (επιβεβαιώνεται από SHACL και reasoner) και πλήρης κάλυψη CQs, κάτι που αποτυπώνεται στο JSON.

Οι μετρικές: `metrics_semantic` δίνουν `precision: 0.2388`, `recall: 0.552`, `f1: 0.3333` με 289 προβλεπόμενες και 69 επικαλυπτόμενες τριπλέτες. Το `metrics_exact` έχει `precision: 0.2749`, `recall: 0.552`, `f1: 0.367`, 251 προβλεπόμενες. Η διαφορά μεταξύ semantic και exact δείχνει ότι η «χαλάρωση» βοηθά λιγότερο από το αναμενόμενο· το exact precision είναι ελαφρώς υψηλότερο επειδή μειώνονται πιθανόν επιπλέον περιγραφές που μετρούνται στη semantic αντιστοίχιση. Αναμενόμενα, η κάλυψη (recall 0.552) είναι υψηλή λόγω δομημένων κανόνων, αλλά το precision παραμένει μέτριο επειδή το σύστημα παράγει γενικεύσεις ή πρόσθετα αξιώματα για να διατηρεί συνέπεια.

Το CQ τμήμα στο `run_report.json` (και επανάληψη στο `iterations`) παρουσιάζει όλους τους ελέγχους ως επιτυχίες, περιλαμβάνοντας ιεραρχίες συναλλαγών, συνδέσεις ATM–Bank, datatypes και χρονικά πεδία. Ωστόσο, το JSON υποδηλώνει και αναμενόμενα κενά: οι CQs που αφορούν dispenses, UI unions, power supplies, χρονισμούς, διπλή επικοινωνία, ενημέρωση metrics, απαιτήσεις, credentials, keypads δεν υφίστανται στο σύνολο των 12 ελέγχων (δηλαδή το scenario E2 πιθανότατα χρησιμοποιεί υποσύνολο 12 CQs). Αναμενόμενο αποτέλεσμα: υψηλή επιτυχία στα «core» CQs αλλά πιθανή απουσία πιο σύνθετων ελέγχων.

Σε γενικές γραμμές, το E2 εκπληρώνει την προσδοκία για συμβολικά σταθερή αλλά όχι απαραίτητα υψηλής ακρίβειας παραγόμενη οντολογία. Η αναφορά `notes: "Declared 36 missing owl:Class resource(s)"` προειδοποιεί ότι ο reasoner χρειάστηκε να προσθέσει ετικέτες τάξεων ώστε να διατηρηθεί η συνέπεια, πράγμα που μπορεί να εισάγει υπερ-γενίκευση και να εξηγεί το μειωμένο precision.

## Πείραμα E3 – Few-shot χωρίς repair
Το E3 (`runs/E3_no_repair/run_report.json`) χρησιμοποιεί few-shot παραδείγματα (`few_shot_exemplars: ["FR-1", "FR-2", "FR-1", "FR-2"]`) και έχει 2.916 συνολικά tokens. Το SHACL παραμένει `conforms: true`, ενώ ο reasoner (`pellet`) αναφέρει αφαίρεση 40 μη έγκυρων περιορισμών και 25 δηλωμένες ελλείπουσες κλάσεις. Αναμενόμενα, η few-shot καθοδήγηση μπορεί να βελτιώσει θεματική συνέπεια αλλά, χωρίς repair, ενδέχεται να παράξει επιπλέον περιγραφές.

Οι μετρικές δίνουν `precision: 0.1575`, `recall: 0.552`, `f1: 0.2451` για 438 προβλεπόμενες τριπλέτες και 69 επικαλυπτόμενες. Το recall παραμένει ίδιο με E2 (0.552), κάτι που υποδηλώνει ότι οι βασικές τριπλέτες καλύπτονται. Το precision πέφτει από 0.2749 (E2 exact) σε 0.1575, αναμενόμενο λόγω υπερπαραγωγής που προκύπτει από τα few-shot παραδείγματα – το μοντέλο προσπαθεί να μιμηθεί τα πρότυπα και εισάγει πρόσθετα στοιχεία.

Το `competency_questions` στο run_report και στην iteration 0 εμφανίζει 12/12 επιτυχίες, δηλαδή pass rate 1.0 για το υποσύνολο CQs που αξιολογήθηκαν. Εδώ η αναμενόμενη συμπεριφορά είναι βελτιωμένη κάλυψη βασικών εννοιών (όπως και στο E2) αλλά, χωρίς repair, αυξημένο θόρυβο. Τα αρνητικά success flags για UI displays, power supplies, χρονισμούς, bank computer επικοινωνίες, ενημέρωση metrics, μοντελοποίηση απαιτήσεων και keypads απουσιάζουν γιατί δεν περιλαμβάνονται στις 12 CQs που εκτελέστηκαν – συνεπώς δεν μετρούνται.

Η σταθερότητα στη συμμόρφωση SHACL και στην συνέπεια reasoner δείχνει ότι οι πρόσθετες τριπλέτες δεν παραβιάζουν ρητά περιορισμούς, όμως μειώνουν την ακρίβεια επειδή δεν αντιστοιχούν στο gold. Η αναμενόμενη βελτίωση θα ήταν η ενσωμάτωση repair βρόχου ώστε να αφαιρεθούν «παράσιτα» αξιώματα, κάτι που ακολουθεί στο E4.

## Πείραμα E4 – Πλήρης ροή με default χειρισμό (final)
Η παραλλαγή `E4_full_default` περιλαμβάνει επαναληπτική διαδικασία με repair. Ο φάκελος `final/` περιέχει τις μετρικές και τα τελικά αποτελέσματα. Το `validation_summary.json` δηλώνει μηδενικές παραβιάσεις (hard και soft), συνεπώς το τελικό μοντέλο συμμορφώνεται πλήρως με τους κανόνες ελέγχου.

Τα `metrics_semantic.json` και `metrics_exact.json` συμπίπτουν: `precision: 0.2134`, `recall: 0.536`, `f1: 0.3052`, `pred_triples: 314`, `overlap_triples: 67`. Η αναμενόμενη συμπεριφορά σε full repair είναι ισορροπία ανάμεσα σε E2 (συμβολική) και E3 (few-shot), με στόχο αύξηση precision μέσω αφαιρέσεων. Πράγματι, το precision βελτιώνεται από E3 (0.1575) αλλά υπολείπεται του E2 exact (0.2749). Το recall είναι ελαφρά μικρότερο από E2/E3 (0.536 vs 0.552) λόγω απομάκρυνσης τριπλετών κατά το repair.

Το `cq_results.json` αναφέρει `pass_rate: 0.5238`. Παρότι το αρχείο δεν δίνει ρητά `passed`/`total`, ο αριθμός επιτυχιών είναι 11/21 (ίδιος με E1 seed1). Παρατηρείται ότι οι ίδιες κατηγορίες CQs αποτυγχάνουν: cash dispense, UI display unions, power supplies, timing, bank computer comms, metric updates, requirements modeling, credentials/amount combo, keypad keys. Ο λόγος είναι ότι το repair επικεντρώθηκε στην ικανοποίηση SHACL/hard κανόνων και πιθανώς στις πιο δομικές CQs, αφήνοντας εκτός τα «λειτουργικά λεπτομέρειας» CQs. Αναμενόμενο αποτέλεσμα θα ήταν ένα υψηλότερο pass rate (π.χ. >70%) εάν οι κανόνες hard περιλάμβαναν ρητά αυτά τα μοτίβα – άρα το pass rate 0.52 δείχνει ότι το repair δεν στόχευσε πλήρως τα CQ gaps.

Το μέγεθος των τριπλετών (314) είναι μεγαλύτερο από E2 (251 exact) και E3 (438) αλλά με καλύτερη αναλογία ορθών/λανθασμένων. Αυτό υποδηλώνει ότι η διαδικασία repair πιθανόν πρόσθεσε κάποιες τριπλέτες ώστε να περάσει τους ελέγχους, αλλά δεν κατάφερε να μειώσει δραστικά τον θόρυβο. Αναμενόμενη βελτίωση θα ήταν η χρήση αυστηρότερων hard κανόνων ή μετα-φίλτρων βάσει CQs.

## Πείραμα E4 – Πλήρης ροή με αυστηρούς κανόνες και CQs
Στο `runs/E4_full_hard_and_cq`, τα τελικά αρχεία δείχνουν `validation_summary` χωρίς παραβιάσεις. Οι μετρικές είναι πολύ χαμηλές: `precision: 0.0253`, `recall: 0.176`, `f1: 0.0442`, με 871 προβλεπόμενες τριπλέτες και μόνο 22 επικαλυπτόμενες. Το `pass_rate` στα CQs είναι 0.1905 (~4/21). Αυτό το προφίλ ταιριάζει με ένα repair που επέτρεψε εκτεταμένη παραγωγή (πολλές τριπλέτες) για να καλύψει αυστηρούς κανόνες, αλλά χωρίς αποτελεσματικό έλεγχο θορύβου.

Η αναμενόμενη συμπεριφορά από έναν συνδυασμό «hard rules + CQ» θα ήταν είτε υψηλό pass rate είτε τουλάχιστον βελτιωμένο recall, όμως εδώ το recall πέφτει στο 0.176. Αυτό σημαίνει ότι, παρότι δεν υπάρχουν καταγεγραμμένες παραβιάσεις, το τελικό διάγραμμα δεν αντιστοιχεί στο gold και δεν απαντά στις CQs. Πιθανή εξήγηση είναι ότι οι «hard» κανόνες που ενσωματώθηκαν δεν ταυτίζονται με τους στόχους των CQs ή εφαρμόστηκαν με τρόπο που οδήγησε σε αποκοπή χρήσιμων τριπλετών. Αναμενόμενο αποτέλεσμα (και στόχος βελτίωσης) είναι η ευθυγράμμιση των hard κανόνων με τα CQ μοτίβα ώστε να αποφεύγεται η απώλεια σημασιολογικής πληροφορίας.

## Πείραμα E4 – Παραλλαγές χωρίς τελικό snapshot
Υπάρχουν δύο ακόμα φάκελοι E4: `E4_full_max_only` και `E4_full_ignore_no_hard`. Και οι δύο περιέχουν επαναληπτικά δεδομένα (iter0, iter1, ...), αρχεία `patches.json`, `iteration_log.json`, `shacl_report.ttl`, `cq_results.json` και σε κάποιες περιπτώσεις `llm_error.txt`. Δεν υπάρχει φάκελος `final/`, που υποδηλώνει διακοπή ή μη ολοκλήρωση της ροής.

### E4_full_max_only
Οι επαναλήψεις 0–5 περιλαμβάνουν patch αρχεία και CQ αποτελέσματα, ενώ στο iter5 υπάρχει `llm_error.txt` που υποδεικνύει σφάλμα LLM, πιθανώς διακοπή δημιουργίας patch. Χωρίς τελικό snapshot δεν υπάρχουν μετρικές precision/recall. Οι σταδιακές CQ αξιολογήσεις θα μπορούσαν να συντεθούν για να εκτιμηθεί πρόοδος, αλλά η απουσία τελικού `pred.ttl` σημαίνει ότι δεν υπάρχει σταθερό output. Αναμενόμενο αποτέλεσμα θα ήταν μια σύγκλιση σε pass rate ή μειωμένη παραβίαση SHACL, όμως το σφάλμα κόβει τη διαδικασία.

### E4_full_ignore_no_hard
Εδώ υπάρχουν μόνο iter0 και iter1. Στο iter1 καταγράφεται επίσης `llm_error.txt`, άρα η διαδικασία σταματά πρόωρα. Όπως και στην προηγούμενη παραλλαγή, η έλλειψη τελικού καταλόγου με μετρικές σημαίνει ότι δεν μπορούμε να ποσοτικοποιήσουμε precision/recall. Η αναμενόμενη συμπεριφορά, αν ολοκληρωνόταν, θα ήταν χαμηλότερη συμμόρφωση σε hard κανόνες (καθώς αγνοούνται) αλλά πιθανόν υψηλότερη κάλυψη CQs, κάτι που δεν επαληθεύεται λόγω διακοπής.

## Συγκριτική ανάλυση και αναμενόμενα μοτίβα
1. **Ακρίβεια vs. Κάλυψη:** Τα LLM-only (ιδίως seed1) δείχνουν σχετικά καλή ισορροπία (F1 ~0.48) χάρη σε μέτριο precision και recall. Τα συμβολικά σενάρια (E2) αυξάνουν recall αλλά μειώνουν precision, όπως αναμενόταν. Τα few-shot χωρίς repair (E3) αυξάνουν θόρυβο, μειώνοντας precision, ενώ τα repair σενάρια (E4 default) στοχεύουν να βελτιώσουν precision αλλά θυσιάζουν λίγο recall. Η παραλλαγή hard_and_cq καταρρέει σε precision και recall, πράγμα απρόσμενο και απαιτεί επαναξιολόγηση των κανόνων.
2. **CQ pass rates:** Το E2 και E3 (12/12) παρουσιάζουν τέλεια επιτυχία στο υποσύνολο CQs, ενισχύοντας την ιδέα ότι οι βασικοί έλεγχοι καλύπτονται. Τα E1 seed1 και E4 default πετυχαίνουν ~52% στο πλήρες σύνολο 21 CQs, υποδεικνύοντας ότι τα «προχωρημένα» λειτουργικά ερωτήματα μένουν άλυτα. Το E1 seed2 (9.5%) και το E4 hard_and_cq (19%) αποτυγχάνουν σημαντικά. Η προσδοκία θα ήταν ότι μια παραλλαγή με CQs στο repair θα ανεβάσει το pass rate πάνω από 70%, κάτι που δεν συνέβη.
3. **Συνέπεια & SHACL:** Όλες οι εκτελέσεις με reasoner/SHACL (E2, E3, E4) δείχνουν `conforms: true` και `consistent: true`. Αυτό ταιριάζει με την αναμενόμενη λειτουργία των validators: στόχος τους είναι να εξαλείφουν τυπικές παραβιάσεις, ακόμη κι αν παραμένουν σημασιολογικά λάθη (χαμηλό precision).
4. **Μέγεθος γραφήματος:** Η αύξηση τριπλετών δεν οδηγεί απαραίτητα σε καλύτερα αποτελέσματα. Το E1 seed2 (190 τριπλέτες) είναι χειρότερο από seed1 (156). Το E3 (438) έχει χαμηλό precision. Το E4 hard_and_cq (871) έχει ακόμα χαμηλότερο precision. Συνεπώς, αναμενόμενο βέλτιστο βρίσκεται κοντά στα 150–300 τριπλέτες, όπου το precision δεν καταρρέει και το recall μένει μέτριο.
5. **Ελλείψεις CQs:** Τα αποτυχημένα CQs αφορούν θέματα «λειτουργικής λεπτομέρειας» (dispenses, UI unions, power supplies, timings, bank computer comms, metrics, requirements, credentials+amount, keypad keys). Αναμενόμενο για μελλοντικές εκτελέσεις είναι να ενσωματωθούν ως hard ή soft κανόνες ώστε να ενθαρρυνθεί η δημιουργία αυτών των τριπλετών.

## Προτεινόμενα αναμενόμενα αποτελέσματα/στόχοι για επόμενες εκτελέσεις
- **Στόχος F1 ≥ 0.45** με χρήση repair: Με δεδομένο ότι το E1 seed1 ήδη επιτυγχάνει 0.4769 χωρίς repair, ένα καλά σχεδιασμένο repair βρόχος (π.χ. βελτιωμένη παραλλαγή E4) θα πρέπει να διατηρήσει ή να βελτιώσει αυτό το F1, περιορίζοντας τον θόρυβο χωρίς να θυσιάζει τις χρυσές τριπλέτες. Αναμενόμενη μέθοδος: επαναληπτική αποτίμηση precision-oriented (π.χ. penalize νέες τριπλέτες που δεν υποστηρίζονται από CQs).
- **Pass rate ≥ 0.70 στα 21 CQs:** Δεδομένου ότι οι αποτυχημένες CQs είναι γνωστές, η προσθήκη κανόνων για ATM dispenses, UI unions, power supplies, χρονισμούς, bank computer επικοινωνία, ενημέρωση μετρικών, απαιτήσεις και keypad θα πρέπει να ωθήσει το pass rate πάνω από 70%. Αναμενόμενα, αυτό θα προκύψει από στοχευμένες προτροπές LLM και SHACL shapes.
- **Ελεγχόμενος αριθμός τριπλετών (<= 320):** Τα πειράματα δείχνουν ότι πέρα από ~320 τριπλέτες το precision πέφτει δραστικά. Αναμενόμενο αποτέλεσμα είναι να τεθεί όριο ή regularization στον αριθμό νέων αξιωμάτων ανά επανάληψη.
- **Ενοποίηση CQs στο repair loop:** Η παραλλαγή hard_and_cq δείχνει ότι απλώς ενεργοποιώντας CQs ως constraints δεν εγγυάται επιτυχία. Αναμένεται ότι, με πιο ήπια ενσωμάτωση (π.χ. soft penalties και όχι απόλυτη επιβολή), θα αποτρέπεται η εκρηκτική παραγωγή τριπλετών και θα βελτιώνεται το pass rate.

## Λεπτομερής ερμηνεία JSON για κάθε πείραμα
### run_report και token usage
- **E1 seed1 & seed2:** Παρέχουν μόνο βασικά μεταδεδομένα (mode, triples, token_usage). Αναμενόμενο, καθώς δεν ενεργοποιήθηκαν validators. Η διαφορά prompt vs completion tokens δείχνει ότι το seed1 χρειάστηκε μεγαλύτερη απάντηση (431 tokens) για λιγότερες τριπλέτες σε σχέση με seed2 (288 tokens), πιθανώς λόγω πιο δομημένης αφήγησης.
- **E2:** Περιέχει πλήρη arrays `competency_questions`, `shacl`, `reasoner`, `iterations`. Ο λόγος είναι η ενεργοποίηση validators και η απουσία repair βημάτων. Αναμενόμενο για συμβολικό pipeline.
- **E3:** Παρόμοια δομή με E2 αλλά με `few_shot_exemplars`. Τα `iterations` (μόνο iter0) καταγράφουν την απομάκρυνση 40 invalid restrictions, κάτι που δείχνει προσπάθεια καθαρισμού πριν από reasoning.
- **E4 default:** Δεν έχει `run_report` στην ίδια μορφή, αλλά τα τελικά αρχεία δείχνουν την ολοκλήρωση πολλαπλών επαναλήψεων (iter0, iter1 κ.λπ.) και καταλήγουν σε final snapshot.
- **E4 hard_and_cq:** Αν και δεν επιθεωρήσαμε τα ενδιάμεσα `iteration_log.json`, η τελική εικόνα (πολλές τριπλέτες, χαμηλό precision) υποδηλώνει ότι τα patches πρόσθεταν διαρκώς αξιώματα για να ικανοποιήσουν constraints.
- **E4 max_only / ignore_no_hard:** Τα `iteration_log.json` πιθανότατα περιγράφουν αποτυχίες ή απόπειρες patching μέχρι να διακοπεί η διαδικασία. Αναμενόμενο περιεχόμενο του `llm_error.txt` είναι κάποιο HTTP ή API error, ή εξάντληση token budget.

### metrics_semantic vs metrics_exact
- **E1:** Τα δύο JSON είναι ταυτόσημα, πράγμα που σημαίνει ότι ο «semantic» ορισμός δεν διαφέρει από τον exact για την αξιολόγηση. Αυτό είναι αναμενόμενο σε επίπεδο baseline χωρίς inferencing.
- **E2:** Το semantic precision (0.2388) είναι χαμηλότερο από το exact (0.2749), παρότι τα overlap_triples είναι ίδια (69). Η διαφορά προέρχεται από το διαφορετικό πλήθος pred_triples (289 semantic vs 251 exact), προφανώς επειδή semantic αξιολόγηση επιτρέπει περισσότερες παραγόμενες τριπλέτες. Αναμενόμενο αποτέλεσμα: semantic χαλαρώνει τα κριτήρια και εμφανίζει χαμηλότερο precision.
- **E3:** Τα JSON ταυτίζονται (precision 0.1575), πιθανώς επειδή δεν εφαρμόστηκε ξεχωριστή semantic χαλάρωση. Αυτό ενισχύει την εικόνα ότι η ακρίβεια καταρρέει από το πλήθος τριπλετών.
- **E4 default:** Ταυτοσημία semantic/exact (precision 0.2134) δείχνει ότι το repair δεν διαφοροποίησε τις κατηγορίες τριπλετών για τις δύο αξιολογήσεις.
- **E4 hard_and_cq:** Δεν εντοπίστηκε ξεχωριστό semantic vs exact αρχείο – μόνο `metrics_semantic.json` (προφανώς και exact θα είναι ίδιο). Αναμενόμενο, καθώς η αξιολόγηση έγινε ενιαία.

### cq_results.json ανά εκτέλεση
- **E1 seed1:** Περιέχει πλήρη 21 ερωτήσεις με 11 επιτυχίες. Οι αποτυχίες ομαδοποιούνται σε λειτουργικά και UI/υποδομή θέματα. Αναμενόμενη λίστα στόχων για repair.
- **E1 seed2:** Δεν αναλύσαμε όλες τις εγγραφές αλλά το pass rate 0.095 υποδηλώνει ότι σχεδόν όλες απέτυχαν. Αναμενόμενη αιτία: ασυνεπείς ή λανθασμένες δηλώσεις τάξεων/ιδιοτήτων.
- **E2/E3:** Λίστα 12 ερωτήσεων με 100% επιτυχία. Πιθανόν υποσύνολο βασικών CQs. Αναμενόμενο, καθώς χωρίς repair αξιολογείται μόνο το βασικό schema.
- **E4 default:** Πλήρεις 21 CQs με 11 επιτυχίες, ίδια μοτίβα αποτυχίας με E1 seed1. Δείχνει ότι, αν και το repair έλυσε παραβιάσεις, δεν κάλυψε πρόσθετα CQs.
- **E4 hard_and_cq:** Πλήρεις 21 CQs με 4 επιτυχίες (19%). Αποτυχίες σχεδόν παντού, δείχνοντας ότι το repair είτε απομάκρυνε κρίσιμες τριπλέτες είτε δεν τις παρήγαγε.
- **E4 max_only / ignore_no_hard:** Τα ενδιάμεσα `cq_results.json` θα έδειχναν την εξέλιξη ανά επανάληψη. Αναμενόμενα, το pass rate θα ξεκινούσε χαμηλά και θα βελτιωνόταν, εκτός εάν η διαδικασία σταματούσε λόγω error (όπως συνέβη).

## Αναλυτική περιγραφή αναμενόμενων αποτελεσμάτων (gold alignment)
Η «αναμενόμενη» κατάσταση, εφόσον το μοντέλο ευθυγραμμίζεται πλήρως με το gold, θα παρείχε:
- Precision = Recall = 1.0, F1 = 1.0, pred_triples = gold_triples = 125, overlap_triples = 125.
- CQ pass rate = 1.0 για όλες τις 21 ερωτήσεις.
- SHACL `conforms: true` χωρίς δηλώσεις ελλειπουσών τάξεων ή αφαιρούμενων περιορισμών.
- Reasoner `consistent: true` χωρίς unsatisfiable classes.

Κάθε απόκλιση από αυτή την ιδεατή κατάσταση μπορεί να χαρτογραφηθεί ως εξής:
- **Precision deficit:** Εμφανίζεται όταν προστίθενται αξιώματα που δεν είναι στο gold. Αναμενόμενο κυρίως σε LLM-only ή σε repair με υπερ-παραγωγή (E3, E4 hard_and_cq). Η λύση είναι αυστηρότερο filtering.
- **Recall deficit:** Παρουσιάζεται όταν παραλείπονται gold τριπλέτες. Σε E1 seed2 και E4 hard_and_cq το recall είναι ιδιαίτερα χαμηλό. Αναμενόμενο αίτιο: είτε το LLM δεν παρήγαγε τις σωστές σχέσεις είτε το repair τις αφαίρεσε ως ασυνεπείς.
- **CQ failure:** Ελλιπής κάλυψη συγκεκριμένων λειτουργικών εννοιών. Αναμενόμενος τρόπος αντιμετώπισης: εισαγωγή προτύπων ή templates στις προτροπές LLM, ή SHACL shapes που επιβάλλουν τις αντίστοιχες ιδιότητες.

## Ερμηνεία repair logs και iterations (υψηλού επιπέδου)
Παρόλο που δεν καταγράψαμε λεπτομερώς τα `iteration_log.json` και `patches.json`, η ύπαρξή τους σε E4 παραλλαγές δείχνει την παρακάτω προσδοκώμενη ροή:
1. **iter0:** Γεννά αρχικό draft (LLM). Εκτελεί SHACL, reasoner, CQs. Καταγράφει παραβιάσεις και αποτυχίες.
2. **Patch synthesis:** Με βάση τα αποτελέσματα, παράγονται patches για προσθήκη/αφαίρεση τριπλετών. Τα `patches.json` αποτυπώνουν τις προτεινόμενες αλλαγές.
3. **iter1..n:** Εφαρμόζονται patches, επαναλαμβάνεται ο έλεγχος. Η διαδικασία τερματίζει όταν οι παραβιάσεις μηδενιστούν ή όταν υπάρξει `llm_error` (όπως στα max_only και ignore_no_hard).

Αναμενόμενο αποτέλεσμα ενός επιτυχημένου repair είναι μείωση παραβιάσεων και αύξηση pass rate, κάτι που φαίνεται μόνο στο default (μηδενικές παραβιάσεις) αλλά όχι στο hard_and_cq (χαμηλό pass rate). Η αναντιστοιχία αυτή σημαίνει ότι οι hard κανόνες ενδέχεται να είναι ανεπαρκώς ευθυγραμμισμένοι με τις CQ απαιτήσεις.

## Συνολική ερμηνεία ανά παράμετρο
- **Token usage:** Μεγαλύτερη κατανάλωση tokens (E3 2.916) δεν εγγυάται καλύτερο αποτέλεσμα· εξαρτάται από την ποιότητα προτροπών και guiding examples.
- **Reasoner notes:** Οι δηλώσεις ελλείπουσων κλάσεων (E2: 36, E3: 25) αποτελούν αναμενόμενη τεχνική για να διατηρηθεί συνέπεια. Ωστόσο, μπορεί να εισάγουν αφηρημένες κλάσεις που δεν υπάρχουν στο gold, επιβαρύνοντας το precision.
- **SHACL conformity:** Η σταθερή συμμόρφωση δείχνει ότι τα shapes είτε είναι γενικά είτε οι παραβιάσεις διορθώνονται γρήγορα. Εάν στόχος είναι μεγαλύτερο pass rate, ίσως χρειάζονται πιο εξειδικευμένα shapes που κωδικοποιούν τα αποτυχημένα CQs.
- **LLM errors:** Οι `llm_error.txt` σε max_only και ignore_no_hard υποδηλώνουν λειτουργικά ζητήματα (π.χ. χρόνοι απόκρισης). Αναμενόμενα, η σταθερότητα του συστήματος χρειάζεται βελτίωση για να φτάσουμε σε final snapshots.

## Συμπεράσματα και προτεινόμενα βήματα
1. **Εστίαση σε precision-aware repair:** Τα αποτελέσματα δείχνουν ότι χωρίς repair (E1 seed1) επιτυγχάνεται καλύτερο F1 από ό,τι με hard_and_cq. Άρα το repair πρέπει να δίνει βάρος στην ακρίβεια, όχι μόνο στη συμμόρφωση με κανόνες.
2. **Ευθυγράμμιση CQs με hard κανόνες:** Για να ανέβει το pass rate, οι αποτυχημένες CQs πρέπει να μετατραπούν σε SHACL shapes ή σε explicit prompts μέσα στον repair loop.
3. **Σταθεροποίηση pipeline:** Αποφυγή LLM errors μέσω μικρότερων batch patches, retries ή failover σε άλλο μοντέλο θα επιτρέψει την ολοκλήρωση των max_only/ignore_no_hard εκτελέσεων.
4. **Καλιμπράρισμα μεγέθους γραφήματος:** Θέσπιση upper bound ~320 τριπλετών και penalization για υπερβάσεις θα συγκρατήσει το precision.
5. **Few-shot επιλογή:** Τα παραδείγματα `FR-1`/`FR-2` βοήθησαν στην κάλυψη CQs αλλά αύξησαν θόρυβο. Αναμενόμενο βήμα είναι να επιλεγούν πιο στοχευμένα few-shot που ενσωματώνουν τις αποτυχημένες λειτουργικές έννοιες.

## Αναλυτική προσαρμογή αναμενόμενων αποτελεσμάτων ανά κατηγορία CQs
- **Dispenses (ATM → Money):** Αναμένεται η ιδιότητα `atm:dispenses` με domain ATM και range Money. Για να εκπληρωθεί, πρέπει το LLM ή το repair να εισάγει αυτή την τριπλέτα ρητά. Η αποτυχία σε E1 seed1 και E4 default δείχνει ότι η έννοια δεν παράγεται αυτόματα. Προτείνεται shape που να απαιτεί τουλάχιστον μία ιδιότητα dispenses.
- **UI Union (NormalDisplay, ErrorDisplay):** Απαιτεί union με δύο μέλη. Αναμενόμενο αποτέλεσμα είναι η χρήση `owl:unionOf` λίστας. Η αποτυχία οφείλεται σε πολυπλοκότητα RDF λιστών. Προτείνεται template patch που εισάγει έτοιμη RDF λίστα.
- **Power supplies (Backup/Main):** Αμφότερες ιδιότητες πρέπει να υπάρχουν. Αναμενόμενα, ένα simple rule «ATM hasBackUpPowerSupply some PowerSupply OR hasMainPowerSupply some PowerSupply» θα λύσει το CQ.
- **Timing (Card/Pin Verification):** Ζητά δύο ιδιότητες χρόνου. Προτείνεται προσθήκη datatype property με range `atm:Time`.
- **Bank computer comms (from/to):** Τρία range constraints πρέπει να συνυπάρχουν. Αναμένεται χρήση `rdfs:range` με `atm:BankComputer` και `atm:ATM` αντίστοιχα.
- **Metrics update (updates union):** Απαιτεί union με `atm:ATMtotalFundOfATM` και `atm:AccountBalanceOFAccount`. Η αποτυχία πιθανότατα οφείλεται σε ακριβή RDF λίστα. Προτείνεται pattern-based insertion.
- **Requirements (subject/verb/condition/else):** Αναμένεται πλήρης μοντελοποίηση απαιτήσεων. Η απουσία αυτών των τριπλετών σε πολλά πειράματα δείχνει ότι η πληροφορία δεν αναδύεται από τις βασικές πηγές. Προτείνεται few-shot που δείχνει παράδειγμα requirement statement.
- **Credentials + amount union:** Συνδυασμός PasswordOfCustomer και TransactionAmountOfTransaction. Αναμένεται union pattern.
- **Keypad keys:** Απλή ιδιότητα `atm:consistOfKeys`. Προτείνεται shape που την απαιτεί.

## Τελικός χάρτης αναμενόμενων επιδόσεων (μελλοντικό bench)
| Παραλλαγή | Προτεινόμενο Precision | Προτεινόμενο Recall | Προτεινόμενο F1 | Αναμενόμενος CQ Pass |
|-----------|-----------------------|---------------------|-----------------|-----------------------|
| LLM-only (σταθεροποιημένο) | 0.50 | 0.55 | 0.52 | 0.60 |
| Συμβολικό + light repair | 0.45 | 0.60 | 0.52 | 0.80 |
| Few-shot + precision repair | 0.40 | 0.60 | 0.48 | 0.80 |
| Full repair (default ενισχυμένο) | 0.55 | 0.60 | 0.57 | 0.80 |
| Hard + CQ (ανασχεδιασμένο) | 0.50 | 0.60 | 0.54 | 0.90 |
| Max-only (ολοκληρωμένο) | 0.45 | 0.58 | 0.51 | 0.75 |
| Ignore no hard (ολοκληρωμένο) | 0.42 | 0.60 | 0.49 | 0.70 |

Οι τιμές αυτές αποτελούν «αναμενόμενα» benchmarks με βάση τα ευρήματα και τους στόχους βελτίωσης, όχι πραγματικά αποτελέσματα. Η υλοποίηση των προτάσεων αναμένεται να μετακινήσει τις μετρικές προς αυτές τις τιμές.

## Συνολικός απολογισμός
Τα πειράματα E1–E4 προσφέρουν ένα φάσμα από LLM-only παραγωγές έως πλήρεις ροές repair. Τα σημαντικότερα συμπεράσματα είναι:
- Οι LLM-only εκτελέσεις μπορούν να αποδώσουν μέτρια καλά (seed1), αλλά είναι ευαίσθητες σε στοχαστικότητα (seed2).
- Οι συμβολικές μέθοδοι εξασφαλίζουν συνέπεια και κάλυψη βασικών εννοιών, αλλά χρειάζονται φιλτράρισμα για precision.
- Τα few-shot παραδείγματα αυξάνουν κάλυψη αλλά εισάγουν θόρυβο, άρα απαιτούν repair.
- Το default repair βελτιώνει το precision σε σχέση με E3, αλλά δεν ανεβάζει το CQ pass rate.
- Η παραλλαγή hard_and_cq, αν και μηδενίζει παραβιάσεις, καταλήγει με εξαιρετικά χαμηλές μετρικές, δείχνοντας κακή ευθυγράμμιση κανόνων–στόχων.
- Οι ημιτελείς παραλλαγές max_only και ignore_no_hard εμποδίζουν την εξαγωγή συμπερασμάτων· απαιτούν σταθεροποίηση του pipeline.

Συνολικά, η ανάλυση των JSON αρχείων αναδεικνύει την ανάγκη για ισχυρότερους, precision-oriented μηχανισμούς repair, καθώς και για ρητή ενσωμάτωση των αποτυχημένων CQs ως κανόνες. Τα αναμενόμενα αποτελέσματα που περιγράφονται μπορούν να λειτουργήσουν ως κατευθυντήριες γραμμές για επόμενες υλοποιήσεις και αξιολογήσεις.

## Εκτενής διερεύνηση φακέλων και JSON δομών
### Δομή φακέλου `runs/E1_llm_only_seed1`
Ο φάκελος περιέχει τα αρχεία `run_report.json`, `metrics_semantic.json`, `metrics_exact.json`, `cq_results.json` και το παραχθέν `pred.ttl`. Η απουσία `repair_log` είναι αναμενόμενη για LLM-only. Εάν θέλουμε να εξάγουμε επιπλέον πληροφορία, θα εξετάζαμε την κατανομή των τριπλετών στο TTL για να δούμε ποιες κλάσεις/ιδιότητες κυριαρχούν. Αναμενόμενη εικόνα: κυριαρχία των βασικών κλάσεων (ATM, Bank, Customer, Account) και ιδιοτήτων χειρισμού συναλλαγών, λιγότερες δηλώσεις για απαιτήσεις ή UI.

### Δομή φακέλου `runs/E1_llm_only_seed2`
Παρόμοια αρχεία με το seed1. Το CQ pass rate 0.095 και οι χαμηλές μετρικές συνιστούν ένδειξη ότι το TTL πιθανόν περιέχει ασυνεπείς ή λανθασμένες δηλώσεις (π.χ. λάθος ranges/domains). Αναμενόμενο βήμα διερεύνησης είναι η σύγκριση `pred.ttl` με το seed1 για να εντοπιστούν ποια αξιώματα εκτροχιάζουν το precision.

### Δομή φακέλου `runs/E2_symbolic_only`
Περιέχει πλήρη run_report με `iterations` (μόνο iter0). Τα JSON αποτυπώνουν ότι η διαδικασία σταμάτησε στην πρώτη επανάληψη λόγω μη ύπαρξης παραβιάσεων. Το `pred.ttl` είναι το αποτέλεσμα συμβολικής ανασύνθεσης. Αναμενόμενη δομή TTL: ευθυγράμμιση με οντολογικά patterns (π.χ. χρήση owl:Restriction, unionOf). Οι 36 δηλωμένες ελλείπουσες κλάσεις πιθανόν εμφανίζονται με ανώνυμες αναφορές σε περιορισμούς allValuesFrom/someValuesFrom, κάτι που θα ήταν εμφανές σε προσεκτική ανάγνωση του TTL.

### Δομή φακέλου `runs/E3_no_repair`
Περιλαμβάνει αντίστοιχα αρχεία με E2 αλλά με πρόσθετο few-shot meta. Τα 40 invalid restrictions που αφαιρέθηκαν θα μπορούσαν να εντοπιστούν στο `iteration_log.json` (αν υπήρχε) ή μέσω σύγκρισης TTL πριν/μετά reasoning. Αναμενόμενη εικόνα: οι υπερβολικές τριπλέτες προκαλούν τους invalid restrictions, αλλά ο reasoner τις αφαιρεί για να διατηρήσει συνέπεια.

### Δομή φακέλου `runs/E4_full_default`
Ο φάκελος περιέχει `iter0`, `iter1` και `final`. Κάθε iter περιλαμβάνει `shacl_report.ttl`, `patches.json`, `iteration_log.json`, `pred.ttl`, `cq_results.json`. Το `repair_log.json` στον root του E4 καταγράφει πιθανότατα τις εντολές patches ανά επανάληψη. Αναμενόμενο σενάριο: iter0 δημιουργεί baseline, iter1 εφαρμόζει patches και στη συνέχεια το final προκύπτει μετά από τουλάχιστον δύο iterations.

### Δομή φακέλου `runs/E4_full_hard_and_cq`
Παρόμοια με το default αλλά με διαφορετική παραμετροποίηση repair. Το υψηλό πλήθος τριπλετών υποδηλώνει ότι τα patches πρόσθεταν συνεχώς αξιώματα. Αναμενόμενο να βρούμε στο `iteration_log` μηνύματα που δείχνουν προσπάθειες ικανοποίησης CQs μέσω προσθήκης unions και restrictions, γεγονός που ανέβασε το μέγεθος χωρίς να αυξήσει την κάλυψη.

### Δομή φακέλου `runs/E4_full_max_only` και `runs/E4_full_ignore_no_hard`
Οι πολλαπλές επαναλήψεις με `llm_error.txt` καταδεικνύουν ότι το σύστημα έφτασε σε αδιέξοδο. Αναμενόμενα περιεχόμενα των `patches.json` θα ήταν προτεινόμενες ενέργειες που δεν εφαρμόστηκαν πλήρως. Η ανάλυση αυτών των αρχείων μπορεί να δείξει αν τα error συνέβησαν λόγω υπερβολικών ή αντικρουόμενων patches.

## Πιθανά αίτια αποκλίσεων και στρατηγικές μετριασμού
1. **Μοντελοποίηση unions:** Πολλά αποτυχημένα CQs απαιτούν RDF λίστες και `owl:unionOf` (UI displays, metrics updates, credentials). Οι LLM και τα patches συχνά δυσκολεύονται με τη σωστή σύνταξη λιστών. Αναμενόμενο mitigation: παροχή «σκληρών» templates RDF λιστών στα prompts ή αυτόματη δημιουργία μέσω helper scripts.
2. **Datatype ασυνέπειες:** Αν και ορισμένα CQs για datatypes πέρασαν (bankCode, timestamps, amounts), άλλες ιδιότητες όπως times για verification αποτυγχάνουν. Ενδέχεται να λείπουν ranges ή να υπάρχουν λάθος τύποι. Αναμενόμενη λύση: validation κανόνες που εντοπίζουν datatype κενά και τα διορθώνουν αυτόματα.
3. **Πολυπλοκότητα περιορισμών allValuesFrom/someValuesFrom:** Οι reasoner notes για δηλωμένες κλάσεις δείχνουν ότι λείπουν explicit `owl:Class` δηλώσεις για resources εντός restrictions. Αυτό μπορεί να μειώνει precision. Προτείνεται shape που δηλώνει αυτόματα τις κλάσεις ή απαλλάσσει από ανώνυμες συσχετίσεις.
4. **Κατεύθυνση σχέσεων:** Ορισμένες CQs ζητούν domains και ranges συγκεκριμένης κατεύθυνσης (π.χ. fromBankComputer vs toBankComputer vs toATM). Λανθασμένη κατεύθυνση μειώνει precision/recall. Αναμενόμενη βελτίωση: κανόνες που ελέγχουν συμμετρία/αντιστροφή ιδιοτήτων και διορθώνουν με βάση gold patterns.
5. **Συνδυασμός hard και soft κανόνων:** Η παραλλαγή hard_and_cq πιθανόν εφαρμόζει υπερβολικά αυστηρούς περιορισμούς, οδηγώντας σε υπερ-παραγωγή ή διαγραφή χρήσιμων τριπλετών. Μια καλύτερη ισορροπία μεταξύ hard (μη διαπραγματεύσιμων) και soft (βαθμολογούμενων) κανόνων θα απέδιδε καλύτερα.

## Σενάρια χρήσης και προσδοκώμενα οφέλη από βελτιώσεις
- **Βελτιωμένες τραπεζικές απαιτήσεις:** Η προσθήκη requirement modeling (subject/verb/condition/else) θα επιτρέψει την εξαγωγή κανόνων επιχειρησιακής λογικής από το διάγραμμα. Αναμενόμενο όφελος: δυνατότητα ελέγχου σεναρίων «εάν/τότε/αλλιώς» και καλύτερη διασύνδεση με συστήματα πολιτικών.
- **Σενάρια ανθεκτικότητας (power supplies):** Η συμπερίληψη εφεδρικών/κύριων τροφοδοσιών θα ενισχύσει την ανάλυση αξιοπιστίας ATM. Αναμενόμενο όφελος: υποστήριξη risk assessment και disaster recovery μοντέλων.
- **Χρονικοί έλεγχοι ασφαλείας:** Η μοντελοποίηση card/pin verification times επιτρέπει SLAs και detection καθυστερήσεων. Αναμενόμενο όφελος: εντοπισμός bottlenecks και security anomalies.
- **Διασύνδεση με bank computer:** Τα CQs για from/to bank computer εξασφαλίζουν αμφίδρομη ροή μηνυμάτων. Αναμενόμενο όφελος: δυνατότητα ανάλυσης failure modes σε δικτυακές επικοινωνίες.
- **UI completeness:** Η ύπαρξη NormalDisplay και ErrorDisplay υποστηρίζει usability και error-handling μελέτες. Αναμενόμενο όφελος: αξιολόγηση εμπειρίας χρήστη και συμμόρφωσης με κανονισμούς προσβασιμότητας.

## Εκτιμήσεις για την επίδραση των seeds και των παραμετροποιήσεων
Η δραματική διαφορά μεταξύ seed1 και seed2 στο E1 καταδεικνύει ότι η στοχαστικότητα του LLM μπορεί να αλλάξει ριζικά την ποιότητα. Αναμενόμενο mitigation: χρήση πολλών seeds και επιλογή του καλύτερου (ensemble), ή καθοδήγηση με deterministic decoding (π.χ. χαμηλό temperature). Αντίστοιχα, η ενεργοποίηση/απενεργοποίηση repair κανόνων αλλάζει δραστικά το αποτέλεσμα, οπότε η παραμετροποίηση πρέπει να τεκμηριώνεται αυστηρά και να συνοδεύεται από ablation μελέτες.

## Περαιτέρω ανάλυση στατιστικών (θεωρητικών) αναμενόμενων
Εάν υποθέσουμε ότι κάθε αποτυχημένο CQ αντιστοιχεί κατά μέσο όρο σε 3–5 τριπλέτες που λείπουν, η βελτίωσή τους θα μπορούσε να αυξήσει το overlap_triples κατά 30–50. Αυτό θα ανέβαζε το recall κατά ~0.24–0.40 ανάλογα με το baseline. Επίσης, εφόσον οι προστιθέμενες τριπλέτες είναι στοχευμένες, το precision θα μειωνόταν ελάχιστα. Αναμενόμενη συνολική επίπτωση: F1 αύξηση κατά 0.1–0.2. Αυτό σημαίνει ότι ένα E4 default που σήμερα έχει F1 0.3052 θα μπορούσε να φτάσει F1 0.40–0.50 με στοχευμένες επεμβάσεις.

## Κατευθυντήριες γραμμές για μελλοντική τεκμηρίωση
Για να αποφευχθούν παρανοήσεις, προτείνεται κάθε μελλοντικό run να συνοδεύεται από:
- **Σύντομο changelog παραμετροποίησης** (π.χ. ποια seeds, ποιοι κανόνες ενεργοποιήθηκαν).
- **Πίνακα CQs με labels** ώστε να φαίνεται γρήγορα ποια θεματική αποτυγχάνει.
- **Δείκτη σταθερότητας LLM** (variance μετρικών σε πολλαπλά seeds) ώστε να εκτιμάται η στοχαστικότητα.
- **Σύνδεση patches με CQs** για να είναι σαφές ποιο patch στοχεύει ποιο ερώτημα.

Εάν ακολουθηθούν οι παραπάνω οδηγίες, τα αναμενόμενα αποτελέσματα θα συγκλίνουν ταχύτερα προς τις τιμές στόχου που προτάθηκαν παραπάνω.
