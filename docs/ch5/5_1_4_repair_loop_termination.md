# 5.1.4 Repair Loop & Termination

Η καρδιά του OG–NSD είναι το repair loop, δηλαδή ο επαναληπτικός κύκλος “validate → prompt → patch”. Η λογική βρίσκεται στο `og_nsd/pipeline.py`, όπου η αρχική οντολογία που παράγεται από το drafting step περνά από SHACL validation (`og_nsd/shacl.py`) και, προαιρετικά, DL reasoning (`og_nsd/reasoning.py`). Τα ευρήματα (violations, unsat classes) μετατρέπονται σε structured feedback, το οποίο τροφοδοτεί ξανά τον LLM ώστε να προτείνει διορθωτικές παρεμβάσεις. Αυτός ο μηχανισμός λειτουργεί ως αντίστοιχο του Counterexample-Guided Inductive Repair: κάθε παραβίαση είναι counterexample και κάθε prompt στοχεύει στην αποκατάσταση.

Σε επίπεδο υλοποίησης, η pipeline διατηρεί τον αριθμό iteration μέσω της παραμέτρου `iterations` στο config. Για κάθε γύρο: (1) εκτελείται validation, (2) συγκεντρώνονται τα violations με λεπτομέρειες (shape, path, severity), (3) συντίθεται prompt με βάση την παραβίαση και το τοπικό graph context, και (4) ο LLM επιστρέφει διορθωτικό Turtle snippet ή patch. Τα νέα axioms ενσωματώνονται στο γράφημα και επαναξιολογούνται. Το αποτέλεσμα κάθε iteration καταγράφεται στο JSON report (`og_nsd/reporting.py`), ώστε να υπάρχει πλήρες ιστορικό των διορθώσεων.

Το termination condition είναι διπλό: (α) αν επιτευχθεί conformance (μηδενικές hard violations και επιτρεπτό επίπεδο soft violations), ή (β) αν εξαντληθεί το προκαθορισμένο budget iterations. Το δεύτερο κριτήριο είναι ουσιώδες για να περιορίσει runtime και κόστος LLM κλήσεων. Το README περιγράφει ότι ο χρήστης ελέγχει το `--iterations` από CLI, ενώ στο config μπορεί να επιλεγεί μικρό budget για γρήγορα runs (π.χ. 1–2 γύροι) ή μεγαλύτερο για μέγιστη συμμόρφωση. Η αξιολόγηση καταγράφει τον αριθμό rounds μέχρι conformance και αυτό λειτουργεί ως metric αποδοτικότητας.

Η επιλογή repair loop αντικατοπτρίζεται στα πειράματα E3 και E4: το E3 είναι “no-repair” (single pass), ενώ το E4 είναι πλήρες repair loop. Αυτό επιτρέπει να μετρηθεί η συμβολή του iterative repair στο F1, στις SHACL παραβιάσεις και στα CQs. Στα logs στο `runs/`, κάθε iteration παράγει ξεχωριστά artefacts, δίνοντας τη δυνατότητα να αναλυθεί πώς εξελίχθηκε το γράφημα από iteration σε iteration.

Η τερματική συνθήκη διασφαλίζει ισορροπία μεταξύ ποιότητας και κόστους. Σε ακαδημαϊκό πλαίσιο, αυτό επιτρέπει να τεκμηριωθούν trade-offs: πόσα iterations απαιτούνται μέχρι conformance, ποια είναι η στατιστική κατανομή “fixed in 1–2 rounds”, και ποιο είναι το υπολειπόμενο ποσοστό παραβιάσεων σε περίπτωση πρόωρου τερματισμού. Αυτή η σχεδίαση καθιστά το σύστημα ελεγχόμενο και συγκρίσιμο με άλλα pipelines που είτε δεν κάνουν repair είτε απαιτούν manual curation.
