# Ακαδημαϊκή αξιολόγηση αποτελεσμάτων του E4

Σκοπός του σημειώματος είναι να αποτυπώσει, με έμφαση στην ερευνητική τεκμηρίωση, τι δείχνουν τα αποτελέσματα όλων των διαθέσιμων εκτελέσεων του E4 (κύριο run και sweep διαφορετικών πολιτικών τερματισμού). Οι αριθμοί συνοψίζουν τα διαθέσιμα αρχεία των runs, χωρίς παράθεση αποσπασμάτων ή κωδικοποιημένων παραπομπών, ώστε να είναι πιο κατάλληλο για ακαδημαϊκή χρήση και ενσωμάτωση σε διπλωματική εργασία.

## Κύριο run `runs/E4_full`
- **Έτρεξε μόνο το iter0.** Το SHACL validation δεν βρήκε ούτε hard ούτε soft violations, δεν προέκυψαν patches και το loop σταμάτησε άμεσα με απόφαση `no_hard_violations`.
- **Κάλυψη CQ:** pass rate 0.57 (12/21), με αποτυχίες σε ερωτήματα που αφορούν διανομή μετρητών, UI display, redundancy και χρονικές απαιτήσεις (9 αποτυχίες συνολικά).
- **Ποιότητα γραφήματος:** exact/semantic F1 = 0.3651 με 69 κοινά τρίπλετς σε 125 του gold (253 προβλεπόμενα).
- **SHACL στο τελικό γράφημα:** καμία παραβίαση καταγεγραμμένη στο `validation_summary.json`, επιβεβαιώνοντας ότι η διακοπή βασίστηκε αποκλειστικά στο «μηδέν hard violations».

## Sweep πολιτικών τερματισμού (`runs/E4_full_sweep`)
- **`default`:** Όπως και στο κύριο run, μηδενικές SHACL παραβιάσεις, 0 patches, τερματισμός στο iter0 λόγω `no_hard_violations`. Η ποιότητα του γραφήματος ανέβηκε οριακά (F1 = 0.4059 με 69 κοινά τρίπλετς / 215 παραχθέντα).
- **`hard_and_cq`:** Η ίδια εικόνα (0 SHACL, 0 patches)· τερματισμός στο iter0 επειδή ταυτόχρονα δεν υπάρχουν hard violations και το CQ threshold θεωρείται ικανοποιημένο, άρα δεν ενεργοποιείται repair loop. Οι μετρικές παραμένουν F1 = 0.4059.
- **`ignore_no_hard`:** Παρά την πολιτική που επιτρέπει συνέχιση όταν δεν υπάρχουν hard violations, η απουσία patches οδήγησε σε τερματισμό στο iter0 με reason `no_patches_available`. Οι μετρικές ταυτίζονται με τις δύο προηγούμενες εκτελέσεις (F1 = 0.4059).
- **`max_only`:** Το iter0 είχε ξανά 0 SHACL violations και 57% CQ pass rate χωρίς patches, όμως το iter1 απέτυχε λόγω `patch_parse_error` από λανθασμένη Turtle έξοδο, οπότε δεν παράχθηκε τελικό γράφημα/μετρικές.

## Επιπλέον run με `max_only` (`runs/E4_full/max_only`)
- Εκτέλεση που άφησε το loop να συνεχίσει μέχρι να χτυπήσει σφάλμα: οι επαναλήψεις iter0–iter5 είχαν σταθερά 0 SHACL violations, 57% CQ pass rate και καμία δημιουργία patch, έως ότου στο iter6 προέκυψε `patch_parse_error` (Turtle συντακτικό σφάλμα) που διέκοψε το loop χωρίς τελικό σύνολο μετρικών.

## Τι προκύπτει για ερευνητική ανάλυση
1. **Η έλλειψη SHACL παραβιάσεων σημαίνει ότι το loop δεν ενεργοποιείται από constraints.** Όλες οι πολιτικές τερματισμού σταμάτησαν στο iter0 όταν δεν υπήρχαν hard violations, παρότι τα CQ δείχνουν μη ικανοποιημένες λειτουργικές απαιτήσεις (π.χ. ATM redundancy, UI error displays).
2. **Οι πολιτικές τερματισμού δεν επηρεάζουν ουσιαστικά τα αποτελέσματα χωρίς patches.** `default`, `hard_and_cq` και `ignore_no_hard` παρήγαγαν σχεδόν ταυτόσημα γραφήματα και μετρικές, επειδή το σήμα τερματισμού καθορίστηκε από το 0 hard violations και την απουσία διαθέσιμων patches.
3. **Τα LLM outputs είναι εύθραυστα όταν ζητούνται patches.** Στις πολιτικές `max_only`, τα loops σταμάτησαν από συντακτικά σφάλματα Turtle (`patch_parse_error`), πριν παραχθεί οποιοδήποτε βελτιωμένο γράφημα, δείχνοντας ανάγκη για ισχυρότερη εξομάλυνση/επαλήθευση των LLM patches πριν την επανεκτέλεση reasoning/validation.
4. **Διαφορά μεταξύ CQ και structural μετρικών.** Ακόμη και χωρίς SHACL violations, οι CQ αποτυχίες κρατούν την κάλυψη λειτουργικών απαιτήσεων χαμηλά (57%), ενώ το F1 κυμαίνεται 0.36–0.41 χάρη σε ταξινομικές σχέσεις που παράγονται από το ontology-aware drafting· αυτό υπογραμμίζει ότι οι λειτουργικές CQ απαιτούν επιπλέον σήματα (instances ή CQ-driven patches) ώστε να βελτιωθούν οι πραγματικά χρήσιμες έννοιες του γραφήματος.
